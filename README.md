# command-on-demand
Enable Self-Service MDM command invocation, without exposing Jamf API credentials in scripts.

## How does that work then?
`command-on-demand` is a web service which sits between your scripts and the Jamf API.

The service exposes a small API surface which your scripts call, authorised with a separate bearer token.

Various checks are carried out to determine how requests are sent to Jamf (or if they should be sent at all).

## Use cases
This tool was built with a few specific use cases in mind
- Self-Service Erase All Content & Settings (`EraseDevice` command)
- Self-Service software updates (e.g. an `InstallASAP` command with forced reboot)
- Any other commands which come in the future and make sense to make available via Self-Service

Without giving users admin or putting Jamf API creds in scripts, this isn't really possible... until now!

## Self-Service Erase All Content & Settings
Since macOS Monterey, Macs with a T2 chip or Apple Silicon CPU behave differently when getting an `EraseDevice` command from Jamf - they quickly return to factory state! üéâ

There are a number of reasons to offer a Self-Service, admin-less nuke & pave.
Maybe your org routinely loans out devices which need to be cleared for the next user, and you don't give field technicians Jamf console access.
Or maybe you want to wipe your devices as part of an MDM migration üíÄ.

Of course, this tool doesn't handle the UX that you'll likely want to present to your users, but there will be some example scripts added to this repo soon.

## Self-Service Software Updates
At the moment, only Self-Service erase is supported, but I'd like to add this when I find the time... PRs welcome! ‚ù§Ô∏è

## Wait... This still requires putting a credential in my script!
Well, yes, but, having the bearer token is only the first step...

Clients can only cause a command to be sent to _themselves_ and only if they can prove established trust with the Jamf server
and that they can modify a chosen part of _their_ Jamf device record:

1. The client requests a code, this is randomly generated by the server and is only valid for two minutes 
2. The client must then cause that code to be set in a designated extension attribute in Jamf via `jamf recon`
3. Once the recon process finishes, the client sends a second request, causing the service to check the value in Jamf 
4. The service then looks up the computer in Jamf and reads the value in the designated extension attribute
5. If the string in Jamf matches the one that was generated, the service sends the `EraseDevice` command to that device via the Jamf API

By successfully modifying an extension attribute value using the `jamf` binary,
we can be sure that the device has a valid device certificate which Jamf trusts. Since devices can only update their own device record this way, 
and taking into account the short lifespan of the code, we can be confident that the requesting client is the one that should receive the command.

**This service absolutely should be run behind a load balancer or reverse proxy which handles TLS termination.**
This also presents the opportunity to use mTLS with client certificates as an extra protection if you need it. Most cloud platforms offer this capability.

## Should I use this?
Only you can answer that. However, this project is still in its early stages.

Previously, I've used tools like Okta Workflows or Pipedream to achieve the same thing (and you can too!).
But sharing solutions for those platforms isn't always easy and not everyone can/wants to use them... also I wanted to learn Go and give something back to the MacAdmin & Jamf community, so that's why this exists!

‚ö†Ô∏è So, **here's the disclaimer** - I'm not an expert (Go) programmer; you may find bugs or see things you don't like (yes, I still need to write tests).
I cannot be held responsible for anything (bad) that happens if you use (or don't use) the code in any of the repos on my GitHub. Use at your own risk, see LICENSE, etc. ‚ö†Ô∏è

If you want to contribute or point out how things can be improved, **please do**!

Things I want to implement/improve:
- Self-Service Software Update with configurable params for things like target OS version, restart behaviour, etc
- Tests
- Logging, Errors and project structure can probably be done better
- The overall code quality, specifically where not idiomatic Go (or just bad Go)
- Any other (good/reasonable) ideas that surface 

## I'm still here, how do I use it?
I'll write a full Wiki eventually, but here are the cliff notes...

### Configure Jamf
- Create an admin user with the following permissions and set a strong password
  - Jamf Pro Server Objects > Computers > **Create** & **Read**
  - Jamf Pro Server Actions > **Send Computer Remote Wipe Command**
- Create a _Computer_ Extension attribute:
  - Give it a sensible name (you'll need this later). E.g. `cmdod-code`
  - Data Type: **String**
  - Input Type: **Script**
  - See the examples below for the script content, but you're free to do what you want here. The only requirement is that the extension attribute reads the received code accurately - _beware of whitespace_.

### Extension Attribute

#### Simple Extension Attribute
```shell
#!/bin/zsh

# Command-On-Demand Code Proof Extension Attribute

CODE_TEMP_PATH="/tmp/.cmdod.code"

if [[ -f "$CODE_TEMP_PATH" ]]; then
	CODE_VALUE=$(cat "$CODE_TEMP_PATH")
fi

echo "<result>$CODE_VALUE</result>"
```
This extension attribute simply reads out the contents of a file, you client side script just needs to ensure it's properly written to the same path.

#### Fancier Extension Attribute requiring a counterpart device script (see below)
```shell
#!/bin/zsh

# Command-On-Demand Code Proof Extension Attribute

CODE_YIELDER_PATH="/tmp/.cmdod.code.sh"

if [[ -x "$CODE_YIELDER_PATH" ]]; then
	CODE_VALUE=$("$CODE_YIELDER_PATH")
fi

echo "<result>$CODE_VALUE</result>"
```
This extension attribute script is designed to run another script (rather than just read a file), which I've called the "yielder".
You'd place this yielder on disk as part of your client side script run.

#### Fancier, self-destructing code "yielder" script
The tiny, self-destructing script that the "fancier" extension attribute above would run.
```shell
#!/bin/zsh
echo -n "aCodeValueThatGotInjectedByAnOuterScript"
rm -f $0
```

An abridged example of this in use within an outer script, potentially being run via Self Service...
```shell
#!/bin/zsh

# Client script being run from Self Service

# ... snip ...

CODE_YIELDER_PATH=/tmp/.cmdod.code.sh
CODE_VALUE=$(curl "https://cmdod.example.com/api/v1/code/$UDID" -H "Authorization: Bearer xxx")

# handle curl errors, continuing if ok

# write code yielder script to disk
cat << EOF > "$CODE_YIELDER_PATH"
#!/bin/zsh
echo -n "$CODE_VALUE"
rm -f \$0
EOF

chmod 700 "$CODE_YIELDER_PATH"

jamf recon

# ... snip ....
```
The idea with this "fancier" approach is that when the extension attribute script runs during recon, it runs the yielder, which echos out the code _and then deletes itself_.
This is nice because on subsequent recon runs, an empty value will be returned, and will therefore clear out the previously stored code in Jamf too.

### Run locally for quick testing with Docker
_**Note:** The included Dockerfile is for reference only, tweak it to your preferences, or maybe don't use it at all._
- Clone this repo and `cd` into it
- Create a `.env` file and set required variable values (see below)
  - Hint: Using `openssl rand -hex 32` is useful for generating a bearer token value
- Run `docker build --no-cache -t command-on-demand .`
- Run `docker run --env-file .env --rm -p 8080:8080 command-on-demand`
  - Don't forget to update the port mapping if you changed the listen port in `.env`

#### Example .env file
```dotenv
# app ignores variables not prefixed with CMDOD_

# Required Variables

# Hostname with domain of your Jamf instance, no need to add the https://
CMDOD_JAMF_FQDN=yourorg.jamfcloud.com

# Credentials for a Jamf admin user with appropriate permissions
CMDOD_JAMF_API_PASSWORD=password
CMDOD_JAMF_API_USER=username

# The name of the Jamf Extension Attribute which will contain the device submitted secret
CMDOD_CODE_PROOF_EA_NAME=example-ea-name

# The bearer token used by clients to make requests to the cmdod service
CMDOD_SERVER_BEARER_TOKEN=veryLongTokenValue

# Optional Variables
# uncomment to change defaults
#CMDOD_SERVER_LISTEN_INTERFACE=0.0.0.0
#CMDOD_SERVER_LISTEN_PORT=8080
```

### Test from a client
**‚ò†Ô∏è THIS WILL ERASE THE TARGET CLIENT IF YOU ALREADY SET EVERYTHING UP ON THE JAMF SIDE ‚ò†Ô∏è**

1. `curl http://localhost:8080/api/v1/code/{UDID-OF-TARGET-HOST} -H "Authorization: Bearer yourCmdODServiceBearerToken"`
2. How you get the returned code into a Jamf extension attribute is up to you at this point, see examples above
3. `curl -X POST http://localhost:8080/api/v1/eraseme/{UDID-OF-TARGET-HOST} -H "Authorization: Bearer yourCmdODServiceBearerToken"`

### Run for prod
_If_ or how you do that is up to you, but there should be a Digital Ocean deployment button here soon‚Ñ¢Ô∏è.

*Whatever you do, put it behind a HTTPS balancer/reverse proxy - the service currently uses only HTTP for its endpoints. (Calls to Jamf are HTTPS)*

### Are there fuller client side scripts/examples?
These will appear on the wiki in the near future